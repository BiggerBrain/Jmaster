跟踪并监控每个Java对象，当某个对象处于不可达状态时，回收该对象所占用的内存

清理内存分配、回收过程中产生的内存碎片

垃圾回收的基本算法
    1.串行回收（Serial）和并行回收（Parallel）
        串行回收就是不管系统有多少个CPU，始终只有一个CPU来执行垃圾回收操作；
        并行回收就是把整个回收工作拆分成多部分，每个部分由一个CPU负责，从而让多个CPU并行回收。并行回收的执行效率很高，
            但复杂度增加，另外也有其他一些副作用，比如内存碎片会增加。
    2.并发执行（Concurrent）和应用程序停止（Stop-the-world）
        应用程序停止的垃圾回收方式在执行垃圾回收的同时会导致应用程序的暂停；
        并发的垃圾回收虽然不会导致应用程序的暂停，但由于并发执行垃圾回收需要解决和应用程序的执行冲突（应用程序可能会在垃圾回收的过程中修改对象），
        因此并发执行垃圾回收的系统开销比应用程序停止更高，而且执行时也需要更多的堆内存。
    3.压缩（Compacting和不压缩（Non-compacting）和复制（Copying）
        为了减少内存碎片，支持压缩的垃圾回收器会把所有的活对象搬迁到一起，然后将之前占用的内存全部回收
        不压缩式的垃圾回收器只是回收内存，这样回收回来的内存不可能是连续的，因此将会有较多的内存碎片。
        较之压缩式的垃圾回收，不压缩式的垃圾回收回收内存快，而分配内存时就会更慢，而且无法解决内存碎片的问题。
        复制式的垃圾回收会将所有可达对象复制到另一块相同的内存中，这种方式的优点是垃圾回收过程不会产生内存碎片，但缺点也很明显，需要复制数据和额外的内存。

        复制：将堆内存分成两个相同空间，从根（类似于前面介绍的有向图的起始定点）开始访问每一个关联的可达对象，
        将空间A的可达对象全部复制到空间B，然后一次性回收整个空A
        缺点：需要巨大的复制成本和较多的内存

        标记清除（mark-sweep）：也就是不压缩的回收方式，垃圾回收器从根开始访问所有可达对象，将它们标记为可达状态，然后再遍历一次整个内存区域，
        把所有没有标记为可达的对象进行回收处理
        缺点：遍历（两次）成本较大，垃圾回收回来的内存往往是不连续的，整理后的堆内存里的碎片很多。

        标记压缩（mark-sweep-compact）：这是压缩方式，这种方式充分利用上述两种算法的优点，垃圾回收器先从根开始访问所有可达对象，
        将它们标记为可达对象。接下来垃圾回收器会将这些活动对象搬迁在一起，这个过程也被称为内存压缩，然后垃圾回收器机制再次回收那些不可达对象所占用的内存空间
        这样就避免了回收产生的内存碎片。



Young（年轻代）
Old（老年代）
Permanent（永久代）
“分代回收”的策略基于如下：
    1.绝大多数的对象不会被长时间引用，这些对象在其Young期间就会被回收；
    2.很老的对象（生存时间很长）和很新的对象（生存时间很短）之间很少存在相互引用的情况

大部分垃圾回收器对Young代都采用复制算法


Young代
    由1个Eden区和2个Survivor区构成。绝大多数对象先分配到Een区（有一些大的对象可能会直接被分配到Old代），Survivor区中的对象都至少在Young代中经历过一次垃圾回收，
    所以这些对象在被转移到Old代之前会先保留在Survivor空间中。同一时间2个Survivor空间中有一个用来保存对象，而另一个是空的，用来在下次垃圾回收时保存Young代中的对象。
    每次复制就是将Eden和第1个Survivor的可达对象复制到第2个Survivor区，然后清空Eden和第1个Survivor区。
    Eden和Survivor的比例通过-XX:SurvivorRatio附加选项来设定，默认为32，如果Survivor太大会产生浪费，太小则会使一些Young代的对象提前进入Old代。

Old代
    特征：
        1.Old代垃圾回收的执行频率无需太高，因为很少有对象会死掉
        2.每次对Old代执行垃圾回收需要更长的时间来完成
    基于以上，垃圾回收器通过会使用标记压缩算法，这种算法可以避免复制Old代的大量对象，而且由于Old代的对象不会很快死亡，回收过程不会大量的产生内存碎片，因此相对比较划算。


Permanent代
    Permanent代主要装在Class、方法等信息，默认为64M，垃圾回收机制通常不会回收Permanent代中的对象。

